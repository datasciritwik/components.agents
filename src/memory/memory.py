import duckdb
from langchain_core.messages import BaseMessage
from typing import List

class MemoryManager:
    def __init__(self, db_path: str):
        self.conn = duckdb.connect(db_path)
        self._create_tables()

    def _create_tables(self):
        # Drop tables if they exist to recreate with correct schema
        self.conn.execute("DROP TABLE IF EXISTS conversation;")
        self.conn.execute("DROP TABLE IF EXISTS summary;")
        self.conn.execute("DROP TABLE IF EXISTS job_insights;")
        
        # Create tables with correct DuckDB syntax
        self.conn.execute("""
            CREATE TABLE conversation (
                id INTEGER PRIMARY KEY,
                role TEXT,
                content TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        
        self.conn.execute("""
            CREATE SEQUENCE IF NOT EXISTS conv_seq START 1;
        """)
        
        self.conn.execute("""
            CREATE TABLE summary (
                id INTEGER PRIMARY KEY,
                summary TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        
        self.conn.execute("""
            CREATE SEQUENCE IF NOT EXISTS summary_seq START 1;
        """)
        
        self.conn.execute("""
            CREATE TABLE job_insights (
                id INTEGER PRIMARY KEY,
                markdown TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """)
        
        self.conn.execute("""
            CREATE SEQUENCE IF NOT EXISTS job_seq START 1;
        """)

    def append_message(self, message: BaseMessage):
        try:
            role = type(message).__name__.replace("Message", "").lower()
            # Use nextval to get the next sequence value
            self.conn.execute(
                "INSERT INTO conversation (id, role, content) VALUES (nextval('conv_seq'), ?, ?);",
                (role, str(message.content))
            )
        except Exception as e:
            print(f"Error appending message: {e}")
            # Fallback: try without explicit ID (let DuckDB handle it)
            try:
                self.conn.execute(
                    "INSERT INTO conversation (role, content) VALUES (?, ?);",
                    (role, str(message.content))
                )
            except Exception as e2:
                print(f"Fallback also failed: {e2}")

    def get_recent_messages(self, limit: int = 10) -> List[BaseMessage]:
        try:
            rows = self.conn.execute(
                "SELECT role, content FROM conversation ORDER BY id DESC LIMIT ?;",
                (limit,)
            ).fetchall()
            return [self._row_to_message(role, content) for role, content in reversed(rows)]
        except Exception as e:
            print(f"Error getting recent messages: {e}")
            return []

    def _row_to_message(self, role, content) -> BaseMessage:
        from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
        mapping = {
            "human": HumanMessage,
            "ai": AIMessage,
            "system": SystemMessage
        }
        return mapping.get(role, HumanMessage)(content=content)

    def summarize_to_long_term(self):
        try:
            rows = self.conn.execute(
                "SELECT content FROM conversation ORDER BY id DESC LIMIT 20"
            ).fetchall()
            text = "\n".join(str(row[0]) for row in rows)
            # This is a placeholder — plug in your own summarizer
            summary = f"Summary:\n{text[:500]}..."  # Ideally call your LLM to summarize
            self.conn.execute(
                "INSERT INTO summary (id, summary) VALUES (nextval('summary_seq'), ?);", 
                (summary,)
            )
        except Exception as e:
            print(f"Error creating summary: {e}")
        
    def store_job_markdown(self, job_data: List[dict], tips: str):
        """
        job_data: List of dicts from tool results, e.g.
        [{"title": ..., "company": ..., "location": ..., "link": ..., "requirements": ...}, ...]
        tips: Suggestions generated by the agent
        """
        try:
            md = "# 📄 Job Opportunities\n\n"
            for job in job_data:
                md += f"## 🏢 {job.get('title', 'Unknown')} at {job.get('company', 'Unknown')}\n"
                md += f"- 📍 Location: {job.get('location', 'N/A')}\n"
                md += f"- 🔗 [Apply Here]({job.get('link', '#')})\n"
                md += f"- 📋 Requirements:\n```\n{job.get('requirements', 'N/A')}\n```\n\n"

            md += "\n---\n"
            md += "## 💡 Suggestions & Tips\n"
            md += f"{tips.strip()}\n"

            self.conn.execute(
                "INSERT INTO job_insights (id, markdown) VALUES (nextval('job_seq'), ?);", 
                (md,)
            )
        except Exception as e:
            print(f"Error storing job markdown: {e}")
        
    def get_all_job_markdowns(self) -> List[str]:
        try:
            rows = self.conn.execute(
                "SELECT markdown FROM job_insights ORDER BY id DESC"
            ).fetchall()
            return [row[0] for row in rows]
        except Exception as e:
            print(f"Error getting job markdowns: {e}")
            return []

    def clear_all_data(self):
        """Utility method to clear all data for testing"""
        try:
            self.conn.execute("DELETE FROM conversation;")
            self.conn.execute("DELETE FROM summary;")
            self.conn.execute("DELETE FROM job_insights;")
            print("All data cleared successfully")
        except Exception as e:
            print(f"Error clearing data: {e}")

    def get_table_info(self):
        """Debug method to check table structure"""
        try:
            tables = self.conn.execute("SHOW TABLES;").fetchall()
            print("Tables:", tables)
            
            for table in ['conversation', 'summary', 'job_insights']:
                try:
                    schema = self.conn.execute(f"DESCRIBE {table};").fetchall()
                    print(f"\n{table} schema:", schema)
                    
                    count = self.conn.execute(f"SELECT COUNT(*) FROM {table};").fetchone()
                    print(f"{table} count:", count[0])
                except Exception as e:
                    print(f"Error checking {table}: {e}")
                    
        except Exception as e:
            print(f"Error getting table info: {e}")